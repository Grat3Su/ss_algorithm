package BOJ.algostudy;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class SOL_BOJ_11559_Puyo {
	    static char[][] map;
	    static int[] dx = {0, 1, 0, -1};
	    static int[] dy = {1, 0, -1, 0};
	    static boolean[][] visited;
	    static ArrayList<Node> list;
	    static int N = 12, M = 6;
	    
	    public static void main(String[] args) throws IOException {
	    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	        
	        map = new char[N][M];
	        for(int i = 0; i < N; i++) {
	            String field = br.readLine();
	            for(int j = 0; j < M; j++) {
	                map[i][j] = field.charAt(j); 
	            }
	        }
	        
	        int count = 0;
	        //board를 탐색하며 4개 이상 뭉쳐있는 노드를 확인한다.
	        while(true) {
	            boolean isFinished = true;
	            visited = new boolean[N][M];
	            for(int i = 0; i < N; i++) {
	                for(int j = 0; j < M; j++) {
	                    if(map[i][j] != '.') {
	                        list = new ArrayList<>();
	                        bfs(map[i][j], i, j);
	                        
	                        if(list.size() >= 4) {
	                            isFinished = false; //연쇄가 일어났으므로 더 탐색해보아야 한다.
	                            for(int k = 0; k < list.size(); k++) {
	                                map[list.get(k).x][list.get(k).y] = '.'; // 터트려서 없앰
	                            }
	                        }
	                    }
	                }
	            }
	            if(isFinished) break;
	            fallPuyos(); // 뿌요들을 떨어뜨린다.
	            count++;
	        }
	        System.out.println(count);
	    }
	    
	    public static void fallPuyos() {        
	        for (int i = 0; i < M; i++) {
	            for (int j = N - 1; j > 0; j--) {
	                if (map[j][i] == '.') {
	                    for (int k = j - 1; k >= 0; k--) {
	                        if (map[k][i] != '.') {
	                            map[j][i] = map[k][i];
	                            map[k][i] = '.';
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	    }
	    
	    public static void bfs(char c, int x, int y) {
	        Queue<Node> q = new LinkedList<>();
	        list.add(new Node(x, y));
	        q.offer(new Node(x, y));
	        visited[x][y] = true;
	        
	        while(!q.isEmpty()) {
	            Node current = q.poll();
	            
	            for(int i = 0; i < 4; i++) {
	                int nx = current.x + dx[i];
	                int ny = current.y + dy[i];
	                
	                if(nx >= 0 && ny >= 0 && nx < N && ny < M && visited[nx][ny] == false && map[nx][ny] == c) {
	                    visited[nx][ny] = true;
	                    list.add(new Node(nx, ny));
	                    q.offer(new Node(nx, ny));
	                }
	            }
	        }
	    }
	 
	    public static class Node {
	        int x;
	        int y;
	        
	        public Node(int x, int y) {
	            this.x = x;
	            this.y = y;
	        }
	    }
	}    
